{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExplainedCursorResponse = exports.CursorResponse = exports.MongoDBResponse = exports.isErrorResponse = void 0;\nconst bson_1 = require(\"../../bson\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst document_1 = require(\"./on_demand/document\");\n/**\n * Accepts a BSON payload and checks for na \"ok: 0\" element.\n * This utility is intended to prevent calling response class constructors\n * that expect the result to be a success and demand certain properties to exist.\n *\n * For example, a cursor response always expects a cursor embedded document.\n * In order to write the class such that the properties reflect that assertion (non-null)\n * we cannot invoke the subclass constructor if the BSON represents an error.\n *\n * @param bytes - BSON document returned from the server\n */\nfunction isErrorResponse(bson, elements) {\n  for (let eIdx = 0; eIdx < elements.length; eIdx++) {\n    const element = elements[eIdx];\n    if (element[2 /* BSONElementOffset.nameLength */] === 2) {\n      const nameOffset = element[1 /* BSONElementOffset.nameOffset */];\n      // 111 == \"o\", 107 == \"k\"\n      if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {\n        const valueOffset = element[3 /* BSONElementOffset.offset */];\n        const valueLength = element[4 /* BSONElementOffset.length */];\n        // If any byte in the length of the ok number (works for any type) is non zero,\n        // then it is considered \"ok: 1\"\n        for (let i = valueOffset; i < valueOffset + valueLength; i++) {\n          if (bson[i] !== 0x00) return false;\n        }\n        return true;\n      }\n    }\n  }\n  return true;\n}\nexports.isErrorResponse = isErrorResponse;\n/** @internal */\nclass MongoDBResponse extends document_1.OnDemandDocument {\n  get(name, as, required) {\n    try {\n      return super.get(name, as, required);\n    } catch (cause) {\n      throw new error_1.MongoUnexpectedServerResponseError(cause.message, {\n        cause\n      });\n    }\n  }\n  static is(value) {\n    return value instanceof MongoDBResponse;\n  }\n  static make(bson) {\n    const elements = (0, bson_1.parseToElementsToArray)(bson, 0);\n    const isError = isErrorResponse(bson, elements);\n    return isError ? new MongoDBResponse(bson, 0, false, elements) : new this(bson, 0, false, elements);\n  }\n  /**\n   * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the\n   * contents of the document.\n   */\n  get recoveryToken() {\n    return this.get('recoveryToken', bson_1.BSONType.object)?.toObject({\n      promoteValues: false,\n      promoteLongs: false,\n      promoteBuffers: false,\n      validation: {\n        utf8: true\n      }\n    }) ?? null;\n  }\n  /**\n   * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.\n   * For the distinct command the server adds a top-level atClusterTime field to the response.\n   * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.\n   */\n  get atClusterTime() {\n    return this.get('cursor', bson_1.BSONType.object)?.get('atClusterTime', bson_1.BSONType.timestamp) ?? this.get('atClusterTime', bson_1.BSONType.timestamp);\n  }\n  get operationTime() {\n    return this.get('operationTime', bson_1.BSONType.timestamp);\n  }\n  /** Normalizes whatever BSON value is \"ok\" to a JS number 1 or 0. */\n  get ok() {\n    return this.getNumber('ok') ? 1 : 0;\n  }\n  get $err() {\n    return this.get('$err', bson_1.BSONType.string);\n  }\n  get errmsg() {\n    return this.get('errmsg', bson_1.BSONType.string);\n  }\n  get code() {\n    return this.getNumber('code');\n  }\n  get $clusterTime() {\n    if (!('clusterTime' in this)) {\n      const clusterTimeDoc = this.get('$clusterTime', bson_1.BSONType.object);\n      if (clusterTimeDoc == null) {\n        this.clusterTime = null;\n        return null;\n      }\n      const clusterTime = clusterTimeDoc.get('clusterTime', bson_1.BSONType.timestamp, true);\n      const signature = clusterTimeDoc.get('signature', bson_1.BSONType.object)?.toObject();\n      // @ts-expect-error: `signature` is incorrectly typed. It is public API.\n      this.clusterTime = {\n        clusterTime,\n        signature\n      };\n    }\n    return this.clusterTime ?? null;\n  }\n  toObject(options) {\n    const exactBSONOptions = {\n      ...(0, bson_1.pluckBSONSerializeOptions)(options ?? {}),\n      validation: (0, bson_1.parseUtf8ValidationOption)(options)\n    };\n    return super.toObject(exactBSONOptions);\n  }\n}\n// {ok:1}\nMongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));\nexports.MongoDBResponse = MongoDBResponse;\n/** @internal */\nclass CursorResponse extends MongoDBResponse {\n  constructor() {\n    super(...arguments);\n    this._batch = null;\n    this.iterated = 0;\n    this._encryptedBatch = null;\n  }\n  static is(value) {\n    return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;\n  }\n  get cursor() {\n    return this.get('cursor', bson_1.BSONType.object, true);\n  }\n  get id() {\n    try {\n      return bson_1.Long.fromBigInt(this.cursor.get('id', bson_1.BSONType.long, true));\n    } catch (cause) {\n      throw new error_1.MongoUnexpectedServerResponseError(cause.message, {\n        cause\n      });\n    }\n  }\n  get ns() {\n    const namespace = this.cursor.get('ns', bson_1.BSONType.string);\n    if (namespace != null) return (0, utils_1.ns)(namespace);\n    return null;\n  }\n  get length() {\n    return Math.max(this.batchSize - this.iterated, 0);\n  }\n  get encryptedBatch() {\n    if (this.encryptedResponse == null) return null;\n    if (this._encryptedBatch != null) return this._encryptedBatch;\n    const cursor = this.encryptedResponse?.get('cursor', bson_1.BSONType.object);\n    if (cursor?.has('firstBatch')) this._encryptedBatch = cursor.get('firstBatch', bson_1.BSONType.array, true);else if (cursor?.has('nextBatch')) this._encryptedBatch = cursor.get('nextBatch', bson_1.BSONType.array, true);else throw new error_1.MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n    return this._encryptedBatch;\n  }\n  get batch() {\n    if (this._batch != null) return this._batch;\n    const cursor = this.cursor;\n    if (cursor.has('firstBatch')) this._batch = cursor.get('firstBatch', bson_1.BSONType.array, true);else if (cursor.has('nextBatch')) this._batch = cursor.get('nextBatch', bson_1.BSONType.array, true);else throw new error_1.MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n    return this._batch;\n  }\n  get batchSize() {\n    return this.batch?.size();\n  }\n  get postBatchResumeToken() {\n    return this.cursor.get('postBatchResumeToken', bson_1.BSONType.object)?.toObject({\n      promoteValues: false,\n      promoteLongs: false,\n      promoteBuffers: false,\n      validation: {\n        utf8: true\n      }\n    }) ?? null;\n  }\n  shift(options) {\n    if (this.iterated >= this.batchSize) {\n      return null;\n    }\n    const result = this.batch.get(this.iterated, bson_1.BSONType.object, true) ?? null;\n    const encryptedResult = this.encryptedBatch?.get(this.iterated, bson_1.BSONType.object, true) ?? null;\n    this.iterated += 1;\n    if (options?.raw) {\n      return result.toBytes();\n    } else {\n      const object = result.toObject(options);\n      if (encryptedResult) {\n        (0, utils_1.decorateDecryptionResult)(object, encryptedResult.toObject(options), true);\n      }\n      return object;\n    }\n  }\n  clear() {\n    this.iterated = this.batchSize;\n  }\n}\n/**\n * This supports a feature of the FindCursor.\n * It is an optimization to avoid an extra getMore when the limit has been reached\n */\nCursorResponse.emptyGetMore = {\n  id: new bson_1.Long(0),\n  length: 0,\n  shift: () => null\n};\nexports.CursorResponse = CursorResponse;\n/**\n * Explain responses have nothing to do with cursor responses\n * This class serves to temporarily avoid refactoring how cursors handle\n * explain responses which is to detect that the response is not cursor-like and return the explain\n * result as the \"first and only\" document in the \"batch\" and end the \"cursor\"\n */\nclass ExplainedCursorResponse extends CursorResponse {\n  constructor() {\n    super(...arguments);\n    this.isExplain = true;\n    this._length = 1;\n  }\n  get id() {\n    return bson_1.Long.fromBigInt(0n);\n  }\n  get batchSize() {\n    return 0;\n  }\n  get ns() {\n    return null;\n  }\n  get length() {\n    return this._length;\n  }\n  shift(options) {\n    if (this._length === 0) return null;\n    this._length -= 1;\n    return this.toObject(options);\n  }\n}\nexports.ExplainedCursorResponse = ExplainedCursorResponse;","map":{"version":3,"names":["bson_1","require","error_1","utils_1","document_1","isErrorResponse","bson","elements","eIdx","length","element","nameOffset","valueOffset","valueLength","i","exports","MongoDBResponse","OnDemandDocument","get","name","as","required","cause","MongoUnexpectedServerResponseError","message","is","value","make","parseToElementsToArray","isError","recoveryToken","BSONType","object","toObject","promoteValues","promoteLongs","promoteBuffers","validation","utf8","atClusterTime","timestamp","operationTime","ok","getNumber","$err","string","errmsg","code","$clusterTime","clusterTimeDoc","clusterTime","signature","options","exactBSONOptions","pluckBSONSerializeOptions","parseUtf8ValidationOption","empty","Uint8Array","CursorResponse","constructor","_batch","iterated","_encryptedBatch","emptyGetMore","cursor","id","Long","fromBigInt","long","ns","namespace","Math","max","batchSize","encryptedBatch","encryptedResponse","has","array","batch","size","postBatchResumeToken","shift","result","encryptedResult","raw","toBytes","decorateDecryptionResult","clear","ExplainedCursorResponse","isExplain","_length"],"sources":["D:\\School\\referencia\\webapp\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\responses.ts"],"sourcesContent":["import { type DeserializeOptions } from 'bson';\n\nimport {\n  type BSONElement,\n  type BSONSerializeOptions,\n  BSONType,\n  type Document,\n  Long,\n  parseToElementsToArray,\n  parseUtf8ValidationOption,\n  pluckBSONSerializeOptions,\n  type Timestamp\n} from '../../bson';\nimport { MongoUnexpectedServerResponseError } from '../../error';\nimport { type ClusterTime } from '../../sdam/common';\nimport { decorateDecryptionResult, ns } from '../../utils';\nimport {\n  type JSTypeOf,\n  OnDemandDocument,\n  type OnDemandDocumentDeserializeOptions\n} from './on_demand/document';\n\n// eslint-disable-next-line no-restricted-syntax\nconst enum BSONElementOffset {\n  type = 0,\n  nameOffset = 1,\n  nameLength = 2,\n  offset = 3,\n  length = 4\n}\n/**\n * Accepts a BSON payload and checks for na \"ok: 0\" element.\n * This utility is intended to prevent calling response class constructors\n * that expect the result to be a success and demand certain properties to exist.\n *\n * For example, a cursor response always expects a cursor embedded document.\n * In order to write the class such that the properties reflect that assertion (non-null)\n * we cannot invoke the subclass constructor if the BSON represents an error.\n *\n * @param bytes - BSON document returned from the server\n */\nexport function isErrorResponse(bson: Uint8Array, elements: BSONElement[]): boolean {\n  for (let eIdx = 0; eIdx < elements.length; eIdx++) {\n    const element = elements[eIdx];\n\n    if (element[BSONElementOffset.nameLength] === 2) {\n      const nameOffset = element[BSONElementOffset.nameOffset];\n\n      // 111 == \"o\", 107 == \"k\"\n      if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {\n        const valueOffset = element[BSONElementOffset.offset];\n        const valueLength = element[BSONElementOffset.length];\n\n        // If any byte in the length of the ok number (works for any type) is non zero,\n        // then it is considered \"ok: 1\"\n        for (let i = valueOffset; i < valueOffset + valueLength; i++) {\n          if (bson[i] !== 0x00) return false;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\n/** @internal */\nexport type MongoDBResponseConstructor = {\n  new (bson: Uint8Array, offset?: number, isArray?: boolean): MongoDBResponse;\n  make(bson: Uint8Array): MongoDBResponse;\n};\n\n/** @internal */\nexport class MongoDBResponse extends OnDemandDocument {\n  // Wrap error thrown from BSON\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: false | undefined\n  ): JSTypeOf[T] | null;\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required: true\n  ): JSTypeOf[T];\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: boolean | undefined\n  ): JSTypeOf[T] | null {\n    try {\n      return super.get(name, as, required);\n    } catch (cause) {\n      throw new MongoUnexpectedServerResponseError(cause.message, { cause });\n    }\n  }\n\n  static is(value: unknown): value is MongoDBResponse {\n    return value instanceof MongoDBResponse;\n  }\n\n  static make(bson: Uint8Array) {\n    const elements = parseToElementsToArray(bson, 0);\n    const isError = isErrorResponse(bson, elements);\n    return isError\n      ? new MongoDBResponse(bson, 0, false, elements)\n      : new this(bson, 0, false, elements);\n  }\n\n  // {ok:1}\n  static empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));\n\n  /**\n   * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the\n   * contents of the document.\n   */\n  get recoveryToken(): Document | null {\n    return (\n      this.get('recoveryToken', BSONType.object)?.toObject({\n        promoteValues: false,\n        promoteLongs: false,\n        promoteBuffers: false,\n        validation: { utf8: true }\n      }) ?? null\n    );\n  }\n\n  /**\n   * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.\n   * For the distinct command the server adds a top-level atClusterTime field to the response.\n   * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.\n   */\n  public get atClusterTime(): Timestamp | null {\n    return (\n      this.get('cursor', BSONType.object)?.get('atClusterTime', BSONType.timestamp) ??\n      this.get('atClusterTime', BSONType.timestamp)\n    );\n  }\n\n  public get operationTime(): Timestamp | null {\n    return this.get('operationTime', BSONType.timestamp);\n  }\n\n  /** Normalizes whatever BSON value is \"ok\" to a JS number 1 or 0. */\n  public get ok(): 0 | 1 {\n    return this.getNumber('ok') ? 1 : 0;\n  }\n\n  public get $err(): string | null {\n    return this.get('$err', BSONType.string);\n  }\n\n  public get errmsg(): string | null {\n    return this.get('errmsg', BSONType.string);\n  }\n\n  public get code(): number | null {\n    return this.getNumber('code');\n  }\n\n  private clusterTime?: ClusterTime | null;\n  public get $clusterTime(): ClusterTime | null {\n    if (!('clusterTime' in this)) {\n      const clusterTimeDoc = this.get('$clusterTime', BSONType.object);\n      if (clusterTimeDoc == null) {\n        this.clusterTime = null;\n        return null;\n      }\n      const clusterTime = clusterTimeDoc.get('clusterTime', BSONType.timestamp, true);\n      const signature = clusterTimeDoc.get('signature', BSONType.object)?.toObject();\n      // @ts-expect-error: `signature` is incorrectly typed. It is public API.\n      this.clusterTime = { clusterTime, signature };\n    }\n    return this.clusterTime ?? null;\n  }\n\n  public override toObject(options?: BSONSerializeOptions): Record<string, any> {\n    const exactBSONOptions = {\n      ...pluckBSONSerializeOptions(options ?? {}),\n      validation: parseUtf8ValidationOption(options)\n    };\n    return super.toObject(exactBSONOptions);\n  }\n}\n\n/** @internal */\nexport class CursorResponse extends MongoDBResponse {\n  /**\n   * Devtools need to know which keys were encrypted before the driver automatically decrypted them.\n   * If decorating is enabled (`Symbol.for('@@mdb.decorateDecryptionResult')`), this field will be set,\n   * storing the original encrypted response from the server, so that we can build an object that has\n   * the list of BSON keys that were encrypted stored at a well known symbol: `Symbol.for('@@mdb.decryptedKeys')`.\n   */\n  encryptedResponse?: MongoDBResponse;\n  /**\n   * This supports a feature of the FindCursor.\n   * It is an optimization to avoid an extra getMore when the limit has been reached\n   */\n  static emptyGetMore: CursorResponse = {\n    id: new Long(0),\n    length: 0,\n    shift: () => null\n  } as unknown as CursorResponse;\n\n  static override is(value: unknown): value is CursorResponse {\n    return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;\n  }\n\n  private _batch: OnDemandDocument | null = null;\n  private iterated = 0;\n\n  get cursor() {\n    return this.get('cursor', BSONType.object, true);\n  }\n\n  public get id(): Long {\n    try {\n      return Long.fromBigInt(this.cursor.get('id', BSONType.long, true));\n    } catch (cause) {\n      throw new MongoUnexpectedServerResponseError(cause.message, { cause });\n    }\n  }\n\n  public get ns() {\n    const namespace = this.cursor.get('ns', BSONType.string);\n    if (namespace != null) return ns(namespace);\n    return null;\n  }\n\n  public get length() {\n    return Math.max(this.batchSize - this.iterated, 0);\n  }\n\n  private _encryptedBatch: OnDemandDocument | null = null;\n  get encryptedBatch() {\n    if (this.encryptedResponse == null) return null;\n    if (this._encryptedBatch != null) return this._encryptedBatch;\n\n    const cursor = this.encryptedResponse?.get('cursor', BSONType.object);\n    if (cursor?.has('firstBatch'))\n      this._encryptedBatch = cursor.get('firstBatch', BSONType.array, true);\n    else if (cursor?.has('nextBatch'))\n      this._encryptedBatch = cursor.get('nextBatch', BSONType.array, true);\n    else throw new MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n\n    return this._encryptedBatch;\n  }\n\n  private get batch() {\n    if (this._batch != null) return this._batch;\n    const cursor = this.cursor;\n    if (cursor.has('firstBatch')) this._batch = cursor.get('firstBatch', BSONType.array, true);\n    else if (cursor.has('nextBatch')) this._batch = cursor.get('nextBatch', BSONType.array, true);\n    else throw new MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n    return this._batch;\n  }\n\n  public get batchSize() {\n    return this.batch?.size();\n  }\n\n  public get postBatchResumeToken() {\n    return (\n      this.cursor.get('postBatchResumeToken', BSONType.object)?.toObject({\n        promoteValues: false,\n        promoteLongs: false,\n        promoteBuffers: false,\n        validation: { utf8: true }\n      }) ?? null\n    );\n  }\n\n  public shift(options: OnDemandDocumentDeserializeOptions): any {\n    if (this.iterated >= this.batchSize) {\n      return null;\n    }\n\n    const result = this.batch.get(this.iterated, BSONType.object, true) ?? null;\n    const encryptedResult = this.encryptedBatch?.get(this.iterated, BSONType.object, true) ?? null;\n\n    this.iterated += 1;\n\n    if (options?.raw) {\n      return result.toBytes();\n    } else {\n      const object = result.toObject(options);\n      if (encryptedResult) {\n        decorateDecryptionResult(object, encryptedResult.toObject(options), true);\n      }\n      return object;\n    }\n  }\n\n  public clear() {\n    this.iterated = this.batchSize;\n  }\n}\n\n/**\n * Explain responses have nothing to do with cursor responses\n * This class serves to temporarily avoid refactoring how cursors handle\n * explain responses which is to detect that the response is not cursor-like and return the explain\n * result as the \"first and only\" document in the \"batch\" and end the \"cursor\"\n */\nexport class ExplainedCursorResponse extends CursorResponse {\n  isExplain = true;\n\n  override get id(): Long {\n    return Long.fromBigInt(0n);\n  }\n\n  override get batchSize() {\n    return 0;\n  }\n\n  override get ns() {\n    return null;\n  }\n\n  _length = 1;\n  override get length(): number {\n    return this._length;\n  }\n\n  override shift(options?: DeserializeOptions) {\n    if (this._length === 0) return null;\n    this._length -= 1;\n    return this.toObject(options);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}